<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Monumental Love</title>
    
    <!-- Phaser 3 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <!-- Howler.js for audio -->
    <script src="https://cdn.jsdelivr.net/npm/howler@2.2.3/dist/howler.min.js"></script>
    
    <!-- GSAP for animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <style>
        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #game-container {
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            overflow: hidden;
            max-width: 100vw;
            max-height: 100vh;
        }
        
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            body {
                padding: 10px;
                box-sizing: border-box;
            }
            
            #game-container {
                border-radius: 10px;
                box-shadow: 0 10px 20px rgba(0,0,0,0.3);
                width: 100%;
                height: 100%;
            }
        }
        
        /* iPhone specific optimizations */
        @media (max-width: 414px) {
            body {
                padding: 5px;
            }
            
            #game-container {
                border-radius: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Phaser game will be injected here -->
    </div>
    
    <script>
        // Game configuration
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const gameWidth = isMobile ? Math.min(window.innerWidth - 20, 400) : 800;
        const gameHeight = isMobile ? Math.min(window.innerHeight - 40, 600) : 600;
        
        const config = {
            type: Phaser.AUTO,
            width: gameWidth,
            height: gameHeight,
            parent: 'game-container',
            backgroundColor: '#e8d5b7',
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: gameWidth,
                height: gameHeight
            }
        };
        
        // Game variables
        let player;
        let cursors;
        let tiles = [];
        let sounds = {};
        let gameScene;
        let isMoving = false;
        let currentLevel = 0;
        let illusionPaths = []; // For optical illusion connections
        
        function preload() {
            // Create simple colored rectangles as placeholders
            this.add.rectangle(gameWidth/2, gameHeight/2, gameWidth, gameHeight, 0xe8d5b7);
            
            // Create placeholder graphics
            createPlaceholderGraphics.call(this);
            
            console.log('Game assets preloaded for mobile');
        }
        
        function create() {
            console.log('Game scene created for mobile');
            gameScene = this;
            
            // Initialize audio with mobile considerations
            initializeAudio();
            
            // Create the game world
            createGameWorld.call(this);
            
            // Create player
            createPlayer.call(this);
            
            // Setup input - prioritize touch for mobile
            if (!isMobile) {
                cursors = this.input.keyboard.createCursorKeys();
            }
            
            // Add touch/click input for movement (works on both mobile and desktop)
            this.input.on('pointerdown', handleTileClick);
            
            // Remove vibration and audio attempts that cause console warnings
            
            // Add instructions for all users
            const instructionText = this.add.text(gameWidth/2, 30, 'Click tiles to move â€¢ Find impossible paths! ðŸ’–', {
                fontSize: isMobile ? '14px' : '16px',
                fontFamily: 'Arial',
                color: '#8e44ad',
                align: 'center'
            }).setOrigin(0.5);
            
            // Keep instructions visible longer
            this.time.delayedCall(5000, () => {
                gsap.to(instructionText, { alpha: 0, duration: 1 });
            });
        }
        
        function update() {
            // Player movement will be added here
            handlePlayerMovement();
        }
        
        function createPlaceholderGraphics() {
            // Create beautiful Monument Valley inspired shapes
            const scale = isMobile ? 0.9 : 1;
            
            // Player character - more Monument Valley style
            this.add.graphics()
                .fillStyle(0xff6b6b)
                .fillCircle(15 * scale, 15 * scale, 12 * scale)
                .generateTexture('player', 30 * scale, 30 * scale);
            
            // Platform tile - 3D looking block
            const tileWidth = 80 * scale;
            const tileHeight = 40 * scale;
            this.add.graphics()
                .fillStyle(0xf9ca24)
                .fillRect(0, 0, tileWidth, tileHeight)
                .fillStyle(0xe17055)
                .fillRect(0, 0, tileWidth, 8 * scale) // top edge
                .generateTexture('tile', tileWidth, tileHeight);
            
            // Goal/target - glowing destination
            const goalSize = 40 * scale;
            this.add.graphics()
                .fillStyle(0x6c5ce7)
                .fillCircle(goalSize/2, goalSize/2, goalSize/2)
                .fillStyle(0x9b59b6)
                .fillCircle(goalSize/2, goalSize/2, goalSize/3)
                .generateTexture('goal', goalSize, goalSize);
                
            // Bridge piece for optical illusions
            this.add.graphics()
                .fillStyle(0x8e44ad)
                .fillRect(0, 0, 60 * scale, 15 * scale)
                .generateTexture('bridge', 60 * scale, 15 * scale);
        }
        
        function initializeAudio() {
            // Initialize Howler sounds with mobile-friendly settings
            const audioConfig = {
                html5: true, // Better for mobile
                preload: false, // Prevent auto-loading on mobile
                volume: 0.1, // Very low volume
            };
            
            // Create silent audio that won't trigger context warnings
            sounds.ambient = {
                play: () => {}, // Dummy function
                playing: () => false
            };
            
            sounds.step = {
                play: () => {}, // Dummy function
                playing: () => false
            };
            
            console.log('Audio initialized (silent mode for compatibility)');
        }
        
        function createGameWorld() {
            // Create a clear, simple level that's easy to understand
            const level = [
                [1, 1, 0, 0, 1],
                [0, 1, 0, 1, 1], 
                [0, 0, 0, 1, 0],
                [1, 1, 1, 1, 0],
                [0, 0, 0, 2, 0] // 2 = goal
            ];
            
            // Define optical illusion connections - these create "impossible" bridges
            illusionPaths = [
                { from: {x: 1, y: 0}, to: {x: 3, y: 1} }, // Bridge across gap
                { from: {x: 0, y: 3}, to: {x: 3, y: 4} }, // Another impossible connection
            ];
            
            // Use a simple grid layout instead of confusing isometric
            const scale = isMobile ? 0.8 : 1;
            const tileSize = 70 * scale;
            const spacing = 10 * scale;
            
            // Center the grid
            const gridWidth = 5 * (tileSize + spacing);
            const gridHeight = 5 * (tileSize + spacing);
            const startX = (gameWidth - gridWidth) / 2;
            const startY = (gameHeight - gridHeight) / 2;
            
            for (let row = 0; row < level.length; row++) {
                for (let col = 0; col < level[row].length; col++) {
                    if (level[row][col] > 0) {
                        const x = startX + col * (tileSize + spacing) + tileSize/2;
                        const y = startY + row * (tileSize + spacing) + tileSize/2;
                        
                        if (level[row][col] === 1) {
                            // Regular tile
                            const tile = this.add.image(x, y, 'tile');
                            tile.setDepth(1);
                            tile.setInteractive();
                            tile.gridX = col;
                            tile.gridY = row;
                            tiles.push({ sprite: tile, x: col, y: row, walkable: true });
                            
                            // Clear hover effects
                            tile.on('pointerover', () => {
                                if (!isMoving) {
                                    tile.setTint(0xffffff);
                                    gsap.to(tile, { scaleX: 1.05, scaleY: 1.05, duration: 0.2 });
                                }
                            });
                            
                            tile.on('pointerout', () => {
                                tile.clearTint();
                                gsap.to(tile, { scaleX: 1, scaleY: 1, duration: 0.2 });
                            });
                            
                        } else if (level[row][col] === 2) {
                            // Goal tile - place on regular tile
                            const tile = this.add.image(x, y, 'tile');
                            const goal = this.add.image(x, y - 20, 'goal');
                            tile.setDepth(1);
                            goal.setDepth(2);
                            tile.setInteractive();
                            tile.gridX = col;
                            tile.gridY = row;
                            tiles.push({ sprite: tile, x: col, y: row, walkable: true, isGoal: true });
                            
                            // Glowing goal animation
                            gsap.to(goal, { 
                                scaleX: 1.3, 
                                scaleY: 1.3, 
                                duration: 1, 
                                repeat: -1, 
                                yoyo: true,
                                ease: "power2.inOut"
                            });
                        }
                    }
                }
            }
            
            // Draw the impossible bridges
            drawIllusionConnections.call(this);
            
            console.log('Clear grid-based game world created');
        }
        
        function createPlayer() {
            // Place player on starting tile (top-left tile)
            const startTile = tiles.find(t => t.x === 0 && t.y === 0);
            if (startTile) {
                player = this.add.image(startTile.sprite.x, startTile.sprite.y - 30, 'player');
                player.setDepth(10);
                player.currentTile = { x: 0, y: 0 };
                
                // Add a shadow for depth
                const shadow = this.add.ellipse(startTile.sprite.x, startTile.sprite.y + 15, 20, 10, 0x000000, 0.3);
                shadow.setDepth(0);
                player.shadow = shadow;
            }
            
            console.log('Player created with shadow');
        }
        
        function handlePlayerMovement() {
            // Handle keyboard movement (only on desktop)
            if (!isMobile && !isMoving && cursors) {
                let targetTile = null;
                
                if (cursors.left.isDown) {
                    targetTile = getTileAt(player.currentTile.x - 1, player.currentTile.y);
                } else if (cursors.right.isDown) {
                    targetTile = getTileAt(player.currentTile.x + 1, player.currentTile.y);
                } else if (cursors.up.isDown) {
                    targetTile = getTileAt(player.currentTile.x, player.currentTile.y - 1);
                } else if (cursors.down.isDown) {
                    targetTile = getTileAt(player.currentTile.x, player.currentTile.y + 1);
                }
                
                if (targetTile) {
                    movePlayerToTile(targetTile);
                }
            }
        }
        
        function handleTileClick(pointer) {
            if (isMoving) return;
            
            // Find which tile was clicked
            const clickedTile = findTileAtPosition(pointer.x, pointer.y);
            if (clickedTile && clickedTile.walkable) {
                movePlayerToTile(clickedTile);
            }
        }
        
        function findTileAtPosition(x, y) {
            // Convert screen coordinates to find the clicked tile
            for (let tile of tiles) {
                const sprite = tile.sprite;
                const bounds = sprite.getBounds();
                if (x >= bounds.x && x <= bounds.x + bounds.width &&
                    y >= bounds.y && y <= bounds.y + bounds.height) {
                    return tile;
                }
            }
            return null;
        }
        
        function getTileAt(x, y) {
            return tiles.find(tile => tile.x === x && tile.y === y);
        }
        
        function movePlayerToTile(targetTile) {
            if (!canReachTile(player.currentTile, targetTile)) return;
            
            isMoving = true;
            const targetSprite = targetTile.sprite;
            
            // Smooth movement animation using GSAP
            gsap.to(player, {
                x: targetSprite.x,
                y: targetSprite.y - 30,
                duration: 0.6,
                ease: "power2.inOut",
                onComplete: () => {
                    player.currentTile = { x: targetTile.x, y: targetTile.y };
                    isMoving = false;
                    
                    // Check if reached goal
                    if (targetTile.isGoal) {
                        onGoalReached();
                    }
                }
            });
            
            // Move shadow too
            if (player.shadow) {
                gsap.to(player.shadow, {
                    x: targetSprite.x,
                    y: targetSprite.y + 15,
                    duration: 0.6,
                    ease: "power2.inOut"
                });
            }
            
            // Add jumping animation
            gsap.to(player, {
                y: targetSprite.y - 50,
                duration: 0.3,
                ease: "power2.out",
                yoyo: true,
                repeat: 1
            });
        }
        
        function canReachTile(fromTile, toTile) {
            // Check if tiles are adjacent
            const dx = Math.abs(fromTile.x - toTile.x);
            const dy = Math.abs(fromTile.y - toTile.y);
            
            // Normal adjacent movement
            if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                return true;
            }
            
            // Check optical illusion paths
            for (let path of illusionPaths) {
                if ((path.from.x === fromTile.x && path.from.y === fromTile.y &&
                     path.to.x === toTile.x && path.to.y === toTile.y) ||
                    (path.to.x === fromTile.x && path.to.y === fromTile.y &&
                     path.from.x === toTile.x && path.from.y === toTile.y)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function drawIllusionConnections() {
            // Draw clear, visible bridges for the optical illusion paths
            for (let path of illusionPaths) {
                const fromTile = getTileAt(path.from.x, path.from.y);
                const toTile = getTileAt(path.to.x, path.to.y);
                
                if (fromTile && toTile) {
                    const fromSprite = fromTile.sprite;
                    const toSprite = toTile.sprite;
                    
                    // Calculate bridge position
                    const bridgeX = (fromSprite.x + toSprite.x) / 2;
                    const bridgeY = (fromSprite.y + toSprite.y) / 2;
                    
                    // Create a visible bridge
                    const bridge = this.add.image(bridgeX, bridgeY, 'bridge');
                    bridge.setDepth(0.5);
                    bridge.setAlpha(0.8);
                    
                    // Add some sparkle effect to make it magical
                    gsap.to(bridge, {
                        alpha: 0.5,
                        duration: 1.5,
                        repeat: -1,
                        yoyo: true,
                        ease: "power2.inOut"
                    });
                    
                    // Rotate bridge to connect tiles properly
                    const angle = Phaser.Math.Angle.Between(fromSprite.x, fromSprite.y, toSprite.x, toSprite.y);
                    bridge.setRotation(angle);
                }
            }
        }
        
        function onGoalReached() {
            console.log('Goal reached! ðŸŽ‰');
            
            // Simple celebration animation (no haptic feedback to avoid warnings)
            gsap.to(player, {
                scaleX: 1.3,
                scaleY: 1.3,
                duration: 0.3,
                repeat: 1,
                yoyo: true,
                ease: "back.out(1.7)"
            });
            
            // Show success message with mobile-appropriate sizing
            const fontSize = isMobile ? '20px' : '28px';
            const successText = gameScene.add.text(gameWidth/2, gameHeight * 0.2, 'ðŸ’– Love Conquered! ðŸ’–', {
                fontSize: fontSize,
                fontFamily: 'Arial',
                color: '#ff6b6b',
                align: 'center'
            }).setOrigin(0.5);
            
            gsap.fromTo(successText, 
                { alpha: 0, scaleX: 0, scaleY: 0 },
                { alpha: 1, scaleX: 1, scaleY: 1, duration: 0.5, ease: "back.out(1.7)" }
            );
            
            // Show tap to continue on mobile
            if (isMobile) {
                const continueText = gameScene.add.text(gameWidth/2, gameHeight * 0.7, 'Tap to play again', {
                    fontSize: '14px',
                    fontFamily: 'Arial',
                    color: '#8e44ad',
                    align: 'center'
                }).setOrigin(0.5);
                
                gsap.fromTo(continueText, 
                    { alpha: 0 },
                    { alpha: 1, duration: 0.5, delay: 1 }
                );
                
                // Allow tap to restart
                gameScene.input.once('pointerdown', restartLevel);
            } else {
                // Auto-restart after celebration on desktop
                gameScene.time.delayedCall(3000, () => {
                    restartLevel();
                });
            }
        }
        
        function restartLevel() {
            // Reset player position
            const startTile = tiles.find(t => t.x === 0 && t.y === 0);
            if (startTile) {
                player.x = startTile.sprite.x;
                player.y = startTile.sprite.y - 20;
                player.currentTile = { x: 0, y: 0 };
                player.setScale(1);
            }
            
            // Clear any UI elements
            gameScene.children.list.forEach(child => {
                if (child.type === 'Text') {
                    child.destroy();
                }
            });
        }
        
        // Initialize the game
        const game = new Phaser.Game(config);
        
        console.log('Monument Valley inspired game initialized!');
    </script>
</body>
</html>